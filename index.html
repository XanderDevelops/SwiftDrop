<!DOCTYPE html>
<html>
<head>
    <title>SwiftDrop - Simple File Transfer</title>
    <style>
        body { font-family: system-ui, sans-serif; display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: #f0f2f5; margin: 0; }
        #app { width: 400px; background: #fff; border-radius: 16px; box-shadow: 0 8px 32px rgba(0,0,0,0.1); padding: 30px; text-align: center; }
        .view { display: none; }
        .view.active { display: block; }
        h1 { font-size: 1.8rem; color: #1a237e; margin-bottom: 20px; }
        .btn { display: inline-block; padding: 12px 25px; margin: 10px 5px; font-size: 1rem; font-weight: 600; border-radius: 8px; cursor: pointer; border: none; transition: all 0.2s; }
        .btn:hover { transform: translateY(-2px); }
        .btn-primary { background-color: #1976d2; color: white; }
        .btn-secondary { background-color: #f0f2f5; color: #333; border: 1px solid #d1d8e0; }
        #room-code-input { font-size: 2rem; text-align: center; letter-spacing: 0.5em; width: 100%; padding: 10px 0; border: 1px solid #ccc; border-radius: 8px; box-sizing: border-box; }
        #room-code-display { font-size: 2.5rem; font-weight: 600; color: #1a237e; letter-spacing: 0.1em; margin: 20px 0; }
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid #1976d2; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 20px auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #progress-bar { width: 100%; height: 10px; background-color: #e0e0e0; border-radius: 5px; overflow: hidden; margin: 15px 0 5px 0; }
        #progress { width: 0; height: 100%; background-color: #1976d2; transition: width 0.2s; }
    </style>
</head>
<body>
    <div id="app">
        <!-- Home View -->
        <div id="home-view" class="view active">
            <h1>SwiftDrop</h1>
            <button id="send-btn" class="btn btn-primary">Send File</button>
            <button id="receive-btn" class="btn btn-primary">Receive File</button>
        </div>

        <!-- Sender Views -->
        <div id="sender-loading-view" class="view">
            <h2>Generating your code...</h2>
            <div class="loader"></div>
        </div>
        <div id="sender-code-view" class="view">
            <h2>Your Transfer Code:</h2>
            <div id="room-code-display"></div>
            <p>Tell the receiver to enter this code.</p>
            <h3>Waiting for receiver to connect...</h3>
            <div class="loader"></div>
            <button class="btn btn-secondary cancel-btn">Cancel</button>
        </div>

        <!-- Receiver View -->
        <div id="receiver-view" class="view">
            <h2>Enter Transfer Code</h2>
            <input type="text" id="room-code-input" maxlength="6" />
            <button id="join-btn" class="btn btn-primary">Join</button>
            <button class="btn btn-secondary cancel-btn">Cancel</button>
        </div>

        <!-- Progress View -->
        <div id="progress-view" class="view">
            <h3 id="status"></h3>
            <div id="progress-bar"><div id="progress"></div></div>
            <p id="progress-text"></p>
        </div>

        <!-- Complete View -->
        <div id="complete-view" class="view">
            <h2 id="complete-title"></h2>
            <p id="complete-message"></p>
            <button class="btn btn-primary" onclick="resetApp()">Start Another Transfer</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/streamsaver@2.0.6/StreamSaver.min.js"></script>
    <script>
        const streamSaver = window.streamSaver;
        let peerConnection;
        let dataChannel;
        let pollingInterval;

        const views = document.querySelectorAll('.view');
        function showView(viewId) {
            views.forEach(v => v.classList.remove('active'));
            document.getElementById(viewId).classList.add('active');
        }

        function resetApp() {
            if (peerConnection) peerConnection.close();
            if (pollingInterval) clearInterval(pollingInterval);
            document.getElementById('room-code-input').value = '';
            showView('home-view');
        }

        document.querySelectorAll('.cancel-btn').forEach(b => b.addEventListener('click', resetApp));

        // --- SENDER LOGIC ---
        document.getElementById('send-btn').addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.onchange = e => startSending(e.target.files[0]);
            input.click();
        });

        async function startSending(file) {
            if (!file) { // If user cancels file selection
                resetApp();
                return;
            }
            showView('sender-loading-view');
            peerConnection = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
            dataChannel = peerConnection.createDataChannel('fileTransfer');
            dataChannel.onopen = () => sendFile(file);

            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);

            peerConnection.onicecandidate = async event => {
                if (!event.candidate) {
                    try {
                        const response = await fetch('/api/create', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ offer: peerConnection.localDescription })
                        });
                        if (!response.ok) {
                            const errorData = await response.json();
                            throw new Error(errorData.error || 'Unknown error from server.');
                        }
                        const { code } = await response.json();
                        document.getElementById('room-code-display').textContent = code;
                        showView('sender-code-view');
                        pollForAnswer(code);
                    } catch (e) {
                        alert(`Error creating room: ${e.message}`);
                        resetApp();
                    }
                }
            };
        }

        function pollForAnswer(code) {
            pollingInterval = setInterval(async () => {
                try {
                    const response = await fetch(`/api/room?code=${code}`);
                    if (response.ok) {
                        const room = await response.json();
                        if (room.answer) {
                            clearInterval(pollingInterval);
                            await peerConnection.setRemoteDescription(room.answer);
                        }
                    } else {
                        // Room might have expired or not exist if receiver cancelled/code was bad
                        clearInterval(pollingInterval);
                        const errorData = await response.json();
                        alert(`Room error: ${errorData.error || 'Room expired or does not exist.'}`);
                        resetApp();
                    }
                } catch(e) {
                    clearInterval(pollingInterval);
                    alert('Lost connection to server during polling.');
                    resetApp();
                }
            }, 3000); // Poll every 3 seconds
        }

        async function sendFile(file) {
            showView('progress-view');
            const status = document.getElementById('status');
            const progress = document.getElementById('progress');
            const progressText = document.getElementById('progress-text');

            status.textContent = `Sending: ${file.name}`;
            dataChannel.send(JSON.stringify({ name: file.name, size: file.size }));

            const CHUNK_SIZE = 262144; // 256KB
            let offset = 0;
            const fileReader = new FileReader();

            fileReader.onload = e => {
                // Backpressure handling (wait if buffer is full)
                if (dataChannel.bufferedAmount > dataChannel.bufferedAmountLowThreshold + CHUNK_SIZE * 2) { // Add a small buffer
                    setTimeout(() => fileReader.readAsArrayBuffer(file.slice(offset, offset + CHUNK_SIZE)), 50); // Retry soon
                    return;
                }

                dataChannel.send(e.target.result);
                offset += e.target.result.byteLength;
                const percent = Math.round((offset / file.size) * 100);
                progress.style.width = `${percent}%`;
                progressText.textContent = `${percent}%`;

                if (offset < file.size) {
                    readSlice(offset);
                } else {
                    document.getElementById('complete-title').textContent = 'File Sent!';
                    document.getElementById('complete-message').textContent = `Successfully sent ${file.name}.`;
                    showView('complete-view');
                }
            };
            const readSlice = o => fileReader.readAsArrayBuffer(file.slice(o, o + CHUNK_SIZE));
            readSlice(0);
        }

        // --- RECEIVER LOGIC ---
        document.getElementById('receive-btn').addEventListener('click', () => showView('receiver-view'));
        document.getElementById('join-btn').addEventListener('click', async () => {
            const code = document.getElementById('room-code-input').value;
            if (code.length !== 6) {
                alert('Please enter a 6-digit code.');
                return;
            }

            try {
                const response = await fetch(`/api/room?code=${code}`);
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Unknown room error.');
                }
                const room = await response.json();
                
                peerConnection = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
                peerConnection.ondatachannel = event => {
                    dataChannel = event.channel;
                    receiveFile();
                };

                await peerConnection.setRemoteDescription(room.offer);
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);

                peerConnection.onicecandidate = async event => {
                    if (!event.candidate) {
                        const updateResponse = await fetch('/api/room', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ code, answer: peerConnection.localDescription })
                        });
                        if (!updateResponse.ok) {
                            const errorData = await updateResponse.json();
                            throw new Error(errorData.error || 'Failed to send answer to server.');
                        }
                    }
                };
            } catch (e) {
                alert(`Error joining room: ${e.message}`);
                resetApp();
            }
        });

        function receiveFile() {
            showView('progress-view');
            const status = document.getElementById('status');
            const progress = document.getElementById('progress');
            const progressText = document.getElementById('progress-text');
            let fileInfo, writer, receivedSize = 0;

            dataChannel.onmessage = e => {
                if (typeof e.data === 'string') { // First message is file metadata
                    fileInfo = JSON.parse(e.data);
                    writer = streamSaver.createWriteStream(fileInfo.name, { size: fileInfo.size }).getWriter();
                    status.textContent = `Receiving: ${fileInfo.name}`;
                } else if (writer) { // Subsequent messages are chunks
                    writer.write(new Uint8Array(e.data));
                    receivedSize += e.data.byteLength;
                    const percent = Math.round((receivedSize / fileInfo.size) * 100);
                    progress.style.width = `${percent}%`;
                    progressText.textContent = `${percent}%`;

                    if (receivedSize === fileInfo.size) {
                        writer.close();
                        document.getElementById('complete-title').textContent = 'Download Complete!';
                        document.getElementById('complete-message').textContent = `${fileInfo.name} has been saved to your Downloads.`;
                        showView('complete-view');
                    }
                }
            };
        }

        // --- App Initialization ---
        document.addEventListener('DOMContentLoaded', resetApp);
    </script>
</body>
</html>